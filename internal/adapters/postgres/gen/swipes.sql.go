// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: swipes.sql

package gen

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const swipeExists = `-- name: SwipeExists :one
SELECT EXISTS(
    SELECT 1 FROM swipe_db 
    WHERE initiator_id = $1 AND target_id = $2
)
`

type SwipeExistsParams struct {
	InitiatorID uuid.UUID
	TargetID    uuid.UUID
}

func (q *Queries) SwipeExists(ctx context.Context, arg SwipeExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, swipeExists, arg.InitiatorID, arg.TargetID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const swipesTargetLike = `-- name: SwipesTargetLike :many
SELECT 
    initiator_id,
    target_id,
    initiator_resp,
    target_resp,
    created_at
FROM swipe_db
WHERE target_id = $1 AND initiator_resp = TRUE
ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type SwipesTargetLikeParams struct {
	TargetID uuid.UUID
	Limit    int32
	Offset   int32
}

func (q *Queries) SwipesTargetLike(ctx context.Context, arg SwipesTargetLikeParams) ([]SwipeDb, error) {
	rows, err := q.db.Query(ctx, swipesTargetLike, arg.TargetID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SwipeDb
	for rows.Next() {
		var i SwipeDb
		if err := rows.Scan(
			&i.InitiatorID,
			&i.TargetID,
			&i.InitiatorResp,
			&i.TargetResp,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertInitSwipe = `-- name: UpsertInitSwipe :exec
INSERT INTO swipe_db (initiator_id, target_id, initiator_resp)
VALUES ($1, $2, $3)
ON CONFLICT (initiator_id, target_id) 
DO UPDATE SET 
    initiator_resp = EXCLUDED.initiator_resp
`

type UpsertInitSwipeParams struct {
	InitiatorID   uuid.UUID
	TargetID      uuid.UUID
	InitiatorResp pgtype.Bool
}

func (q *Queries) UpsertInitSwipe(ctx context.Context, arg UpsertInitSwipeParams) error {
	_, err := q.db.Exec(ctx, upsertInitSwipe, arg.InitiatorID, arg.TargetID, arg.InitiatorResp)
	return err
}

const upsertTargetSwipe = `-- name: UpsertTargetSwipe :exec
INSERT INTO swipe_db (initiator_id, target_id, target_resp)
VALUES ($1, $2, $3)
ON CONFLICT (initiator_id, target_id) 
DO UPDATE SET 
    target_resp = EXCLUDED.target_resp
`

type UpsertTargetSwipeParams struct {
	InitiatorID uuid.UUID
	TargetID    uuid.UUID
	TargetResp  pgtype.Bool
}

func (q *Queries) UpsertTargetSwipe(ctx context.Context, arg UpsertTargetSwipeParams) error {
	_, err := q.db.Exec(ctx, upsertTargetSwipe, arg.InitiatorID, arg.TargetID, arg.TargetResp)
	return err
}
